syntax = "proto3";

package agglayer.protocol.types.v1;

import "agglayer/protocol/types/v1/bridge_exit.proto";
import "agglayer/protocol/types/v1/bytes.proto";
import "agglayer/protocol/types/v1/imported_bridge_exit.proto";

// Certificate type.
message Certificate {
  // NetworkID of the origin network.
  uint32 network_id = 1;
  // Simple increment to count the Certificate per network.
  uint64 height = 2;
  // Previous local exit root.
  FixedBytes32 prev_local_exit_root = 3;
  // New local exit root.
  FixedBytes32 new_local_exit_root = 4;
  // List of bridge exits included in this state transition.
  repeated BridgeExit bridge_exits = 5;
  // List of imported bridge exits included in this state transition.
  repeated ImportedBridgeExit imported_bridge_exits = 6;
  // Fixed size field of arbitrary data for the chain needs.
  FixedBytes32 metadata = 7;
  // Aggchain data.
  AggchainData aggchain_data = 8;
  // custom chain data.
  bytes custom_chain_data = 9;
}

// Aggchaindata is the data sent by the aggchain.
message AggchainData {
  // Aggchain proof context to share non-sensitive data.
  //
  // Examples: exact SP1 version, trace id, etc. Basically used for debugging.
  map<string, bytes> context = 1;

  // The data of the aggchain.
  oneof data {
    // Signature committed to the bridge exits and imported bridge exits.
    FixedBytes65 signature = 2;
    // SP1v4 Aggchain proof.
    AggchainProofSp1v4 sp1v4 = 3;
  }
}

// SP1v4 aggchain proof.
message AggchainProofSp1v4 {
  // Digest of the aggchain params.
  FixedBytes32 aggchain_params = 1;
  // The actual proof.
  bytes proof = 2;
}

// Certificate identifier.
message CertificateId {
  // bytes representation of the certificate id.
  FixedBytes32 value = 1;
}
