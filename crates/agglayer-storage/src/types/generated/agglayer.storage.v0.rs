// @generated
// This file is @generated by prost-build.
/// All the possible values that can be stored in the network info.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisabledNetwork {
    /// The timestamp when the network was disabled.
    #[prost(message, optional, tag="1")]
    pub disabled_at: ::core::option::Option<::prost_types::Timestamp>,
    /// The reason who disabled the network.
    #[prost(enumeration="DisabledBy", tag="2")]
    pub disabled_by: i32,
}
/// Enum representing who disabled the network.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DisabledBy {
    /// Default value, should not be used.
    Unspecified = 0,
    /// The network was disabled by an admin.
    Admin = 1,
}
impl DisabledBy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DISABLED_BY_UNSPECIFIED",
            Self::Admin => "DISABLED_BY_ADMIN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DISABLED_BY_UNSPECIFIED" => Some(Self::Unspecified),
            "DISABLED_BY_ADMIN" => Some(Self::Admin),
            _ => None,
        }
    }
}
/// Migration record for tracking database migration state.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MigrationRecord {
}
/// All the possible values that can be stored in the network info.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInfoValue {
    /// The type of value being stored.
    #[prost(oneof="network_info_value::Value", tags="1, 2, 3, 4")]
    pub value: ::core::option::Option<network_info_value::Value>,
}
/// Nested message and enum types in `NetworkInfoValue`.
pub mod network_info_value {
    /// The type of value being stored.
    #[derive(strum_macros::EnumIter, strum_macros::EnumDiscriminants)]
    #[strum_discriminants(derive(strum_macros::EnumIter, strum_macros::FromRepr, strum_macros::EnumCount, serde::Serialize, serde::Deserialize))]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        /// The network type
        #[prost(enumeration="super::NetworkType", tag="1")]
        NetworkType(i32),
        /// Represents the current settled certificate for a given network.
        #[prost(message, tag="2")]
        SettledCertificate(super::SettledCertificate),
        /// Info about the latest settled claim in the network.
        #[prost(message, tag="3")]
        SettledClaim(super::SettledClaim),
        /// The latest pending certificate.
        #[prost(message, tag="4")]
        LatestPendingCertificateInfo(super::LatestPendingCertificateInfo),
    }
}
/// Represents the current settled certificate for a given network.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettledCertificate {
    /// The ID of the latest settled certificate.
    #[prost(message, optional, tag="1")]
    pub certificate_id: ::core::option::Option<SettledCertificateId>,
    /// The pessimistic proof root of the latest settled certificate.
    #[prost(message, optional, tag="2")]
    pub pp_root: ::core::option::Option<SettledPessimisticProofRoot>,
    /// The leaf count of the latest settled local exit tree.
    #[prost(message, optional, tag="3")]
    pub let_leaf_count: ::core::option::Option<SettledLocalExitTreeLeafCount>,
    /// The local exit root of the latest settled certificate.
    #[prost(message, optional, tag="4")]
    pub ler: ::core::option::Option<SettledLocalExitRoot>,
}
/// SettledCertificateId represents the ID of the latest settled certificate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettledCertificateId {
    /// The certificate ID in bytes
    #[prost(bytes="bytes", tag="1")]
    pub id: ::prost::bytes::Bytes,
}
/// The pessimistic proof root of the latest settled certificate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettledPessimisticProofRoot {
    /// The root hash
    #[prost(bytes="bytes", tag="1")]
    pub root: ::prost::bytes::Bytes,
}
/// The local exit root of the latest settled certificate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettledLocalExitRoot {
    /// The root hash
    #[prost(bytes="bytes", tag="1")]
    pub root: ::prost::bytes::Bytes,
}
/// The leaf count of the latest settled local exit tree.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SettledLocalExitTreeLeafCount {
    /// The leaf count
    #[prost(uint64, tag="1")]
    pub settled_let_leaf_count: u64,
}
/// Info about the latest settled claim in the network.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettledClaim {
    /// Global index, indicating uniquely which tree leaf is claimed.
    #[prost(message, optional, tag="1")]
    pub global_index: ::core::option::Option<GlobalIndex>,
    /// Hash of the claimed imported bridge exit.
    #[prost(message, optional, tag="2")]
    pub bridge_exit_hash: ::core::option::Option<BridgeExitHash>,
}
/// Global index, indicating uniquely which tree leaf is claimed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalIndex {
    /// The global index in bytes
    #[prost(bytes="bytes", tag="1")]
    pub value: ::prost::bytes::Bytes,
}
/// / Hash of the claimed imported bridge exit.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BridgeExitHash {
    /// The bridge exit hash in bytes
    #[prost(bytes="bytes", tag="2")]
    pub bridge_exit_hash: ::prost::bytes::Bytes,
}
/// The latest pending certificate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LatestPendingCertificateInfo {
    /// The actual certificate height that is in pending
    #[prost(message, optional, tag="1")]
    pub height: ::core::option::Option<LatestPendingCertificateHeight>,
    /// The ID of the latest pending certificate.
    #[prost(message, optional, tag="2")]
    pub id: ::core::option::Option<LatestPendingCertificateId>,
}
/// The actual certificate height that is in pending
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LatestPendingCertificateHeight {
    /// The height
    #[prost(uint64, tag="1")]
    pub height: u64,
}
/// The ID of the latest pending certificate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LatestPendingCertificateId {
    /// The certificate ID in bytes
    #[prost(bytes="bytes", tag="1")]
    pub id: ::prost::bytes::Bytes,
}
/// The network type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NetworkType {
    /// Unspecified network type.
    Unspecified = 0,
    /// ECDSA-based network type.
    Ecdsa = 1,
    /// Generic network type.
    Generic = 2,
    /// / Multisig-only network type.
    MultisigOnly = 3,
    /// / Multisig and aggchain proof network type.
    MultisigAndAggchainProof = 4,
}
impl NetworkType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NETWORK_TYPE_UNSPECIFIED",
            Self::Ecdsa => "NETWORK_TYPE_ECDSA",
            Self::Generic => "NETWORK_TYPE_GENERIC",
            Self::MultisigOnly => "NETWORK_TYPE_MULTISIG_ONLY",
            Self::MultisigAndAggchainProof => "NETWORK_TYPE_MULTISIG_AND_AGGCHAIN_PROOF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NETWORK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NETWORK_TYPE_ECDSA" => Some(Self::Ecdsa),
            "NETWORK_TYPE_GENERIC" => Some(Self::Generic),
            "NETWORK_TYPE_MULTISIG_ONLY" => Some(Self::MultisigOnly),
            "NETWORK_TYPE_MULTISIG_AND_AGGCHAIN_PROOF" => Some(Self::MultisigAndAggchainProof),
            _ => None,
        }
    }
}
/// Represents a 128-bit unsigned integer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Uint128 {
    /// Value (encoded in big-endian format).
    #[prost(bytes="bytes", tag="1")]
    pub value: ::prost::bytes::Bytes,
}
/// Represents a 256-bit unsigned integer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Uint256 {
    /// Value (encoded in big-endian format).
    #[prost(bytes="bytes", tag="1")]
    pub value: ::prost::bytes::Bytes,
}
/// Represents an Ethereum address.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Address {
    /// Ethereum address (20 bytes).
    #[prost(bytes="bytes", tag="1")]
    pub address: ::prost::bytes::Bytes,
}
/// Represents an Ethereum nonce.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Nonce {
    /// Nonce value.
    #[prost(uint64, tag="1")]
    pub nonce: u64,
}
/// Represents Ethereum transaction calldata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Calldata {
    /// Calldata bytes.
    #[prost(bytes="bytes", tag="1")]
    pub data: ::prost::bytes::Bytes,
}
/// Represents an Ethereum value (256-bit unsigned integer).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EthValue {
    /// Value.
    #[prost(message, optional, tag="1")]
    pub value: ::core::option::Option<Uint256>,
}
/// Transaction hash.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxHash {
    /// Hash bytes.
    #[prost(bytes="bytes", tag="1")]
    pub hash: ::prost::bytes::Bytes,
}
/// Block hash
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHash {
    /// Hash bytes.
    #[prost(bytes="bytes", tag="1")]
    pub hash: ::prost::bytes::Bytes,
}
/// Settlement job ID.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettlementJobId {
    /// ULID byte sequence.
    #[prost(bytes="bytes", tag="1")]
    pub ulid: ::prost::bytes::Bytes,
}
/// Settlement job data.
///
/// ----- Transaction details -----
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettlementJob {
    /// Contract address to which to submit the transaction.
    #[prost(message, optional, tag="1")]
    pub contract_address: ::core::option::Option<Address>,
    /// Transaction calldata.
    #[prost(message, optional, tag="2")]
    pub calldata: ::core::option::Option<Calldata>,
    /// Eth value to send with the transaction.
    #[prost(message, optional, tag="3")]
    pub eth_value: ::core::option::Option<EthValue>,
    // ----- Job result details -----

    /// Job result, if available.
    #[prost(message, optional, tag="4")]
    pub job_result: ::core::option::Option<TxResult>,
    // ----- Transaction parameters -----

    /// Number of confirmations to wait for.
    #[prost(uint32, tag="5")]
    pub num_confirmations: u32,
    /// Gas limit for each settlement attempt.
    #[prost(message, optional, tag="6")]
    pub gas_limit: ::core::option::Option<Uint128>,
    /// Ceiling for max fee per gas.
    #[prost(message, optional, tag="7")]
    pub max_fee_per_gas_ceiling: ::core::option::Option<Uint128>,
    /// Floor for max fee per gas.
    #[prost(message, optional, tag="8")]
    pub max_fee_per_gas_floor: ::core::option::Option<Uint128>,
    /// Percent increase for max fee per gas: each retry will multiply max fee per gas by N / 100.
    #[prost(uint32, tag="9")]
    pub max_fee_per_gas_increase_percents: u32,
    /// Ceiling for max priority fee per gas.
    #[prost(message, optional, tag="10")]
    pub max_priority_fee_per_gas_ceiling: ::core::option::Option<Uint128>,
    /// Floor for max priority fee per gas.
    #[prost(message, optional, tag="11")]
    pub max_priority_fee_per_gas_floor: ::core::option::Option<Uint128>,
    /// Percent increase for max priority fee per gas: each retry will multiply max priority fee per gas by N / 100.
    #[prost(uint32, tag="12")]
    pub max_priority_fee_per_gas_increase_percents: u32,
}
/// Transaction result.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxResult {
    /// Transaction result.
    #[prost(oneof="tx_result::TxResult", tags="1, 2, 3")]
    pub tx_result: ::core::option::Option<tx_result::TxResult>,
}
/// Nested message and enum types in `TxResult`.
pub mod tx_result {
    /// Transaction result.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TxResult {
        /// Error encountered while attempting to submit the transaction, that didn't lead to an on-chain result.
        #[prost(message, tag="1")]
        ClientError(super::ClientError),
        /// Result of a successfully-executed contract call.
        #[prost(message, tag="2")]
        ContractCallResult(super::ContractCallResult),
        /// Reorganized transactions get their result edited to be this.
        #[prost(message, tag="3")]
        ReorganizedResult(::prost::alloc::boxed::Box<super::ReorganizedResult>),
    }
}
/// Error encountered while attempting to submit the transaction, that didn't lead to an on-chain result.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientError {
    /// Type of error.
    #[prost(enumeration="ClientErrorType", tag="1")]
    pub error_type: i32,
    /// Error message.
    #[prost(string, tag="2")]
    pub error_message: ::prost::alloc::string::String,
}
/// Result for a successfully-executed contract call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContractCallResult {
    /// The outcome of the contract call.
    #[prost(enumeration="ContractCallOutcome", tag="1")]
    pub outcome: i32,
    /// Additional metadata about the call outcome.
    #[prost(bytes="bytes", tag="2")]
    pub metadata: ::prost::bytes::Bytes,
    /// Block number where the transaction was included.
    #[prost(message, optional, tag="3")]
    pub block_hash: ::core::option::Option<BlockHash>,
}
/// Result indicating that the transaction's previous result was reorganized out of the chain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReorganizedResult {
    /// Date of the reorg detection.
    #[prost(message, optional, tag="1")]
    pub reorg_detection_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Previous result, that was recorded before the reorg was detected.
    #[prost(message, optional, boxed, tag="2")]
    pub previous_result: ::core::option::Option<::prost::alloc::boxed::Box<TxResult>>,
}
/// Sequence number of a settlement attempt within a settlement job.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AttemptSequenceNumber {
    /// Sequence number.
    #[prost(uint64, tag="1")]
    pub number: u64,
}
/// Contents of the settlement attempts CF.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettlementAttempt {
    /// Sender wallet.
    #[prost(message, optional, tag="1")]
    pub sender_wallet: ::core::option::Option<Address>,
    /// Nonce reserved for the transaction.
    #[prost(message, optional, tag="2")]
    pub nonce: ::core::option::Option<Nonce>,
    /// Gas limit used for this attempt.
    #[prost(message, optional, tag="3")]
    pub gas_limit: ::core::option::Option<Uint128>,
    /// Gas price parameters used for this attempt.
    #[prost(message, optional, tag="4")]
    pub max_fee_per_gas: ::core::option::Option<Uint128>,
    /// Gas price parameters used for this attempt.
    #[prost(message, optional, tag="5")]
    pub max_priority_fee_per_gas: ::core::option::Option<Uint128>,
    /// Hash of the submitted transaction.
    #[prost(message, optional, tag="6")]
    pub tx_hash: ::core::option::Option<TxHash>,
    /// Result of the attempt, if available.
    #[prost(message, optional, tag="7")]
    pub result: ::core::option::Option<TxResult>,
}
/// Contents of the settlement nonces CF.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettlementNonce {
    /// ID of the job that reserved this nonce.
    #[prost(message, optional, tag="1")]
    pub job_id: ::core::option::Option<SettlementJobId>,
    /// Sequence numbers of all of this job's settlement attempts that used this nonce.
    #[prost(message, repeated, tag="2")]
    pub attempt_sequence_numbers: ::prost::alloc::vec::Vec<AttemptSequenceNumber>,
}
/// Type of client error.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClientErrorType {
    /// Unspecified error type.
    Unspecified = 0,
    /// Transient error (e.g., network issue, temporary RPC unavailability).
    UnspecifiedTransient = 1,
    /// Permanent error (e.g., we have no private key for the wallet listed in there).
    UnspecifiedPermanent = 2,
}
impl ClientErrorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CLIENT_ERROR_TYPE_UNSPECIFIED",
            Self::UnspecifiedTransient => "CLIENT_ERROR_TYPE_UNSPECIFIED_TRANSIENT",
            Self::UnspecifiedPermanent => "CLIENT_ERROR_TYPE_UNSPECIFIED_PERMANENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLIENT_ERROR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CLIENT_ERROR_TYPE_UNSPECIFIED_TRANSIENT" => Some(Self::UnspecifiedTransient),
            "CLIENT_ERROR_TYPE_UNSPECIFIED_PERMANENT" => Some(Self::UnspecifiedPermanent),
            _ => None,
        }
    }
}
/// On-chain outcome of the contract call.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ContractCallOutcome {
    /// Unspecified outcome. This should never be used.
    Unspecified = 0,
    /// The call was successful.
    Success = 1,
    /// The call reverted.
    Reverted = 2,
}
impl ContractCallOutcome {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONTRACT_CALL_OUTCOME_UNSPECIFIED",
            Self::Success => "CONTRACT_CALL_OUTCOME_SUCCESS",
            Self::Reverted => "CONTRACT_CALL_OUTCOME_REVERTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONTRACT_CALL_OUTCOME_UNSPECIFIED" => Some(Self::Unspecified),
            "CONTRACT_CALL_OUTCOME_SUCCESS" => Some(Self::Success),
            "CONTRACT_CALL_OUTCOME_REVERTED" => Some(Self::Reverted),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
