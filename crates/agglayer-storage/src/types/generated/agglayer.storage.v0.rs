// @generated
// This file is @generated by prost-build.
/// All the possible values that can be stored in the network info.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInfoValue {
    /// The type of value being stored.
    #[prost(oneof="network_info_value::Value", tags="1, 2, 3, 4")]
    pub value: ::core::option::Option<network_info_value::Value>,
}
/// Nested message and enum types in `NetworkInfoValue`.
pub mod network_info_value {
    /// The type of value being stored.
    #[derive(strum_macros::EnumIter, strum_macros::EnumDiscriminants)]
    #[strum_discriminants(derive(strum_macros::EnumIter, strum_macros::FromRepr, strum_macros::EnumCount, serde::Serialize, serde::Deserialize))]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        /// The network type
        #[prost(enumeration="super::NetworkType", tag="1")]
        NetworkType(i32),
        /// Represents the current settled certificate for a given network.
        #[prost(message, tag="2")]
        SettledCertificate(super::SettledCertificate),
        /// Info about the latest settled claim in the network.
        #[prost(message, tag="3")]
        SettledClaim(super::SettledClaim),
        /// The latest pending certificate.
        #[prost(message, tag="4")]
        LatestPendingCertificateInfo(super::LatestPendingCertificateInfo),
    }
}
/// Represents the current settled certificate for a given network.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettledCertificate {
    /// The ID of the latest settled certificate.
    #[prost(message, optional, tag="1")]
    pub certificate_id: ::core::option::Option<SettledCertificateId>,
    /// The pessimistic proof root of the latest settled certificate.
    #[prost(message, optional, tag="2")]
    pub pp_root: ::core::option::Option<SettledPessimisticProofRoot>,
    /// The leaf count of the latest settled local exit tree.
    #[prost(message, optional, tag="3")]
    pub let_leaf_count: ::core::option::Option<SettledLocalExitTreeLeafCount>,
    /// The local exit root of the latest settled certificate.
    #[prost(message, optional, tag="4")]
    pub ler: ::core::option::Option<SettledLocalExitRoot>,
}
/// SettledCertificateId represents the ID of the latest settled certificate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettledCertificateId {
    /// The certificate ID in bytes
    #[prost(bytes="bytes", tag="1")]
    pub id: ::prost::bytes::Bytes,
}
/// The pessimistic proof root of the latest settled certificate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettledPessimisticProofRoot {
    /// The root hash
    #[prost(bytes="bytes", tag="1")]
    pub root: ::prost::bytes::Bytes,
}
/// The local exit root of the latest settled certificate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettledLocalExitRoot {
    /// The root hash
    #[prost(bytes="bytes", tag="1")]
    pub root: ::prost::bytes::Bytes,
}
/// The leaf count of the latest settled local exit tree.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SettledLocalExitTreeLeafCount {
    /// The leaf count
    #[prost(uint64, tag="1")]
    pub settled_let_leaf_count: u64,
}
/// Info about the latest settled claim in the network.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettledClaim {
    /// Global index, indicating uniquely which tree leaf is claimed.
    #[prost(message, optional, tag="1")]
    pub global_index: ::core::option::Option<GlobalIndex>,
    /// Hash of the claimed imported bridge exit.
    #[prost(message, optional, tag="2")]
    pub bridge_exit_hash: ::core::option::Option<BridgeExitHash>,
}
/// Global index, indicating uniquely which tree leaf is claimed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalIndex {
    /// The global index in bytes
    #[prost(bytes="bytes", tag="1")]
    pub value: ::prost::bytes::Bytes,
}
/// / Hash of the claimed imported bridge exit.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BridgeExitHash {
    /// The bridge exit hash in bytes
    #[prost(bytes="bytes", tag="2")]
    pub bridge_exit_hash: ::prost::bytes::Bytes,
}
/// The latest pending certificate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LatestPendingCertificateInfo {
    /// The actual certificate height that is in pending
    #[prost(message, optional, tag="1")]
    pub height: ::core::option::Option<LatestPendingCertificateHeight>,
    /// The ID of the latest pending certificate.
    #[prost(message, optional, tag="2")]
    pub id: ::core::option::Option<LatestPendingCertificateId>,
}
/// The actual certificate height that is in pending
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LatestPendingCertificateHeight {
    /// The height
    #[prost(uint64, tag="1")]
    pub height: u64,
}
/// The ID of the latest pending certificate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LatestPendingCertificateId {
    /// The certificate ID in bytes
    #[prost(bytes="bytes", tag="1")]
    pub id: ::prost::bytes::Bytes,
}
/// The network type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NetworkType {
    /// Unspecified network type.
    Unspecified = 0,
    /// ECDSA-based network type.
    Ecdsa = 1,
    /// Generic network type.
    Generic = 2,
    /// / Multisig-only network type.
    MultisigOnly = 3,
    /// / Multisig and aggchain proof network type.
    MultisigAndAggchainProof = 4,
}
impl NetworkType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NETWORK_TYPE_UNSPECIFIED",
            Self::Ecdsa => "NETWORK_TYPE_ECDSA",
            Self::Generic => "NETWORK_TYPE_GENERIC",
            Self::MultisigOnly => "NETWORK_TYPE_MULTISIG_ONLY",
            Self::MultisigAndAggchainProof => "NETWORK_TYPE_MULTISIG_AND_AGGCHAIN_PROOF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NETWORK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NETWORK_TYPE_ECDSA" => Some(Self::Ecdsa),
            "NETWORK_TYPE_GENERIC" => Some(Self::Generic),
            "NETWORK_TYPE_MULTISIG_ONLY" => Some(Self::MultisigOnly),
            "NETWORK_TYPE_MULTISIG_AND_AGGCHAIN_PROOF" => Some(Self::MultisigAndAggchainProof),
            _ => None,
        }
    }
}
/// Record of settlement transaction hashes for a certificate.
/// Stores hashes in the order of insertion with automatic deduplication.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettlementTxRecord {
    /// Settlement transaction hash history.
    /// Optional to differentiate between empty history and missing history,
    /// which allows for easier field deprecation in the future.
    #[prost(message, optional, tag="1")]
    pub hashes: ::core::option::Option<TxHashHistory>,
}
/// Transaction hash history wrapper.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxHashHistory {
    /// Settlement transaction hashes, uniqued and in order of insertion.
    /// Each hash represents a settlement transaction associated with a certificate.
    #[prost(bytes="bytes", repeated, tag="1")]
    pub hashes: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
}
// @@protoc_insertion_point(module)
