// @generated
// This file is @generated by prost-build.
/// All the possible values that can be stored in the network info.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInfoValue {
    /// The type of value being stored.
    #[prost(oneof="network_info_value::Value", tags="1, 4, 2, 3")]
    pub value: ::core::option::Option<network_info_value::Value>,
}
/// Nested message and enum types in `NetworkInfoValue`.
pub mod network_info_value {
    /// The type of value being stored.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        /// The network type
        #[prost(enumeration="super::NetworkType", tag="1")]
        NetworkType(i32),
        /// Represents the current settled certificate for a given network.
        #[prost(message, tag="4")]
        SettledCertificate(super::SettledCertificate),
        /// Info about the latest settled claim in the network.
        #[prost(message, tag="2")]
        SettledClaim(super::SettledClaim),
        /// The height of the latest pending certificate.
        #[prost(message, tag="3")]
        LatestPendingHeight(super::LatestPendingHeight),
    }
}
/// Represents the current settled certificate for a given network.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettledCertificate {
    /// The ID of the latest settled certificate.
    #[prost(message, optional, tag="1")]
    pub certificate_id: ::core::option::Option<SettledCertificateId>,
    /// The pessimistic proof root of the latest settled certificate.
    #[prost(message, optional, tag="2")]
    pub new_pp_root: ::core::option::Option<SettledPessimisticProofRoot>,
    /// The leaf count of the latest settled local exit tree.
    #[prost(message, optional, tag="3")]
    pub let_leaf_count: ::core::option::Option<SettledLocalExitTreeLeafCount>,
}
/// Represents the current settled height for a given network.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SettledHeight {
    /// The actual certificate height settled
    #[prost(uint64, tag="1")]
    pub height: u64,
}
/// SettledCertificateId represents the ID of the latest settled certificate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettledCertificateId {
    /// The certificate ID in bytes
    #[prost(bytes="bytes", tag="1")]
    pub id: ::prost::bytes::Bytes,
}
/// The pessimistic proof root of the latest settled certificate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettledPessimisticProofRoot {
    /// The root hash
    #[prost(bytes="bytes", tag="1")]
    pub root: ::prost::bytes::Bytes,
}
/// The local exit root of the latest settled certificate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettledLocalExitRoot {
    /// The root hash
    #[prost(bytes="bytes", tag="1")]
    pub root: ::prost::bytes::Bytes,
}
/// The leaf count of the latest settled local exit tree.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SettledLocalExitTreeLeafCount {
    /// The leaf count
    #[prost(uint64, tag="1")]
    pub settled_let_leaf_count: u64,
}
/// Info about the latest settled claim in the network.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettledClaim {
    /// Global index, indicating uniquely which tree leaf is claimed.
    #[prost(bytes="bytes", tag="1")]
    pub global_index: ::prost::bytes::Bytes,
    /// / Hash of the claimed imported bridge exit.
    #[prost(bytes="bytes", tag="2")]
    pub bridge_exit_hash: ::prost::bytes::Bytes,
}
/// The height of the latest pending certificate.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LatestPendingHeight {
    /// The actual certificate height that is in pending
    #[prost(uint64, tag="1")]
    pub latest_pending_height: u64,
}
/// The network type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NetworkType {
    /// Unspecified network type.
    Unspecified = 0,
    /// ECDSA-based network type.
    Ecdsa = 1,
    /// Generic network type.
    Generic = 2,
    /// / Multisig-only network type.
    MultisigOnly = 3,
    /// / Multisig and aggchain proof network type.
    MultisigAndAggchainProof = 4,
}
impl NetworkType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NETWORK_TYPE_UNSPECIFIED",
            Self::Ecdsa => "NETWORK_TYPE_ECDSA",
            Self::Generic => "NETWORK_TYPE_GENERIC",
            Self::MultisigOnly => "NETWORK_TYPE_MULTISIG_ONLY",
            Self::MultisigAndAggchainProof => "NETWORK_TYPE_MULTISIG_AND_AGGCHAIN_PROOF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NETWORK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NETWORK_TYPE_ECDSA" => Some(Self::Ecdsa),
            "NETWORK_TYPE_GENERIC" => Some(Self::Generic),
            "NETWORK_TYPE_MULTISIG_ONLY" => Some(Self::MultisigOnly),
            "NETWORK_TYPE_MULTISIG_AND_AGGCHAIN_PROOF" => Some(Self::MultisigAndAggchainProof),
            _ => None,
        }
    }
}
include!("agglayer.storage.v0.serde.rs");
// @@protoc_insertion_point(module)